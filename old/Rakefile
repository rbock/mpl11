##############################################################################
# Utilities
##############################################################################
require "benchcc"
require "gnuplot"
require "rake"
require "ruby-progressbar"


def procify(x)
  Proc === x ? x : proc { x }
end

class Plot < Gnuplot::Plot
  include Rake::DSL

  def initialize(name)
    super() { }
    @datasets = task name.to_s + "_datasets", [:compiler]

    # Add a task to draw the plot after the datasets are gathered.
    task name, [:compiler] => [@datasets.name] do
      Gnuplot.open do |process|
        process << to_gplot
        process << store_datasets
      end
    end

    yield self if block_given?
  end

  def dataset(**env, &block)
    block ||= proc { }
    @datasets.enhance do |_, args|
      cc = Benchcc::Compiler[args.compiler]
      ctx = env.merge(compiler: cc)
      data << Gnuplot::DataSet.new { |ds| block.call(ds, ctx) }
    end
  end
end

class ManyInputPlot < Plot
  def dataset(input, y, **env)
    super(**env) do |ds, ctx|
      yield ds, ctx if block_given?

      xs = procify(input).call(ctx).to_a
      progress = ProgressBar.create(format: "#{ds.title} %p%% | %B |", total: xs.size)
      ys = xs.map { |x|
        y.call(ctx.merge(input: x))
         .tap{ progress.increment }
      }
      ds.data = [xs, ys]
    end
  end
end

class TimingPlot < ManyInputPlot
  def initialize(name)
    super do |plot|
      plot.xlabel "Input size"
      plot.ylabel "Compilation time"
      plot.format 'y "%f s"'
      yield plot if block_given?
    end
  end

  attr_accessor :input_file

  def dataset(xs, file = nil, **env, &block)
    file ||= input_file
    compute = -> (ctx) { ctx[:compiler].rtime(file, ctx, repetitions: 1).real }
    super(xs, compute, **env, &block)
  end
end

class MemusgPlot < ManyInputPlot
  def initialize(name)
    super do |plot|
      plot.xlabel "Input size"
      plot.ylabel "Peak memory usage"
      plot.format 'y "%f kb"'
      yield plot if block_given?
    end
  end

  attr_accessor :input_file

  def dataset(xs, file = nil, **env, &block)
    file ||= input_file
    compute = -> (ctx) { raise NotImplementedError }
    super(xs, compute, **env, &block)
  end
end


def range(from, to, step = 1)
  from, to, step = procify(from), procify(to), procify(step)
  proc { |*args|
    (from.call(*args)..to.call(*args)).step(step.call(*args))
  }
end

template_depth = proc { |ctx| ctx[:compiler].template_depth }
constexpr_depth = proc { |ctx| ctx[:compiler].constexpr_depth }


##############################################################################
# Benchmark registration
##############################################################################
task :default => [:all]

desc "Run all the tasks."
task :all => [:comparison, :techniques]

desc "Benchmark MPL vs MPL11."
benchmark_suite :comparison do

  def comparison(name)
    TimingPlot.new name do |plot|
      plot.title name
      plot.term "png"
      plot.output "comparison/#{name}.png"
      plot.input_file = "comparison/#{name}.erb.cpp"
      yield plot if block_given?
    end
  end

  def default_ds
    proc { |ds, ctx|
      ds.with = "lines"
      ds.title = "#{ctx[:config]}" + (ctx[:rules] ? " (with rules)" : "")
    }
  end

  %w{at fmap fmap_nested}.each do |operation|
    comparison operation do |plot|
      plot.input_file = "comparison/sequence_operation.erb.cpp"

      dataset = proc { |*args, **kw|
        plot.dataset(*args, **kw, operation: operation, &default_ds)
      }

      dataset.call(range(1, template_depth), config: "mpl11::list", rules: true)
      dataset.call(range(1, template_depth), config: "mpl11::list", rules: false)
      dataset.call(1..50,  config: "mpl::vector")
      dataset.call(1..50,  config: "mpl::list")
    end
  end

  comparison :plus do |plot|
    plot.dataset(range(2, template_depth), config: :mpl11, &default_ds)
    plot.dataset(2..5,   config: :mpl, &default_ds)
  end
end

desc "Benchmark different implementation techniques."
benchmark_suite :techniques do

  def technique(name)
    TimingPlot.new name do |plot|
      plot.title name
      plot.term "png"
      plot.output "techniques/#{name}.png"
      plot.input_file = "techniques/#{name}.erb.cpp"
      yield plot if block_given?
    end
  end

  technique :alias_vs_struct do |plot|
    plot.dataset((0..10_000).step(20), config: :alias)
    plot.dataset((0..10_000).step(20), config: :struct)
  end

  technique :at_index do |plot|
    plot.dataset(0..500, config: :overload)
    plot.dataset(0..500, config: :multiple_inheritance)
  end

  technique :at_key do |plot|
    plot.dataset(0..500, config: :multiple_inheritance)
    plot.dataset(range(0, template_depth), config: :single_inheritance)
  end

  technique :implement_metafunction do |plot|
    plot.dataset((0..10_000).step(10), config: :specialize)
    plot.dataset((0..10_000).step(10), config: :delegate)
  end

  technique :invoke_metafunction do |plot|
    plot.dataset((0..5_000).step(10), config: :flat_nested_type)
    plot.dataset(range(0, template_depth, 10), config: :recursive_forwarding)
    plot.dataset(range(0, template_depth, 10), config: :recursive_nested_type)
  end

  technique :max do |plot|
    plot.dataset(2..500, config: :union)
    plot.dataset(range(2, constexpr_depth), config: :standard_recursion)
    plot.dataset(range(2, constexpr_depth), config: :recursive_constexpr)
  end

  technique :mention_vs_instantiate do |plot|
    plot.dataset((0..5_000).step(10), config: :mention)
    plot.dataset((0..5_000).step(10), config: :instantiate)
  end

  technique :or do |plot|
    %i{overload noexcept recursive_constexpr specialization}.each { |cfg|
      plot.dataset(0..500, config: cfg)
    }

    plot.dataset(range(0, template_depth), config: :structs)
    plot.dataset(range(0, template_depth), config: :short_circuit_structs)
  end

  technique :sum do |plot|
    plot.dataset(range(2, constexpr_depth), config: :accumulating_constexpr)
    plot.dataset(range(2, constexpr_depth), config: :recursive_constexpr)
    plot.dataset(range(2, template_depth), config: :recursive_struct)
    plot.dataset(2..500, config: :sizeof_trick)
  end

  technique :trampoline do |plot|
    %i{standard_recursion aliases macro_quantifier constexpr_quantifier}.each { |cfg|
      plot.dataset((1..30_000).step(100), config: cfg)
    }
  end

  technique :while do |plot|
    plot.dataset(range(0, template_depth), config: :aliases)
    plot.dataset(range(0, template_depth), config: :standard_recursion)
  end
end